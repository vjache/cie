// mcp_smoke_test — смоук-тест MCP: индексация, запросы, добавление файла, реиндекс, повторный поиск.
// Запуск из корня репо: go run scripts/mcp_smoke_test.go
package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

func main() {
	repoRoot, err := os.Getwd()
	if err != nil {
		fmt.Fprintf(os.Stderr, "getwd: %v\n", err)
		os.Exit(1)
	}
	// Допускаем запуск из scripts/
	if filepath.Base(repoRoot) == "scripts" {
		repoRoot = filepath.Dir(repoRoot)
		if err := os.Chdir(repoRoot); err != nil {
			fmt.Fprintf(os.Stderr, "chdir: %v\n", err)
			os.Exit(1)
		}
	}

	cieBin := filepath.Join(repoRoot, "cie")
	if _, err := os.Stat(cieBin); err != nil {
		cieBin = "cie" // из PATH
	}

	fmt.Println("=== 1. cie init -y (если нет .cie)")
	_ = exec.Command(cieBin, "init", "-y").Run()

	fmt.Println("=== 2. cie index")
	cmdIndex := exec.Command(cieBin, "index")
	cmdIndex.Dir = repoRoot
	cmdIndex.Stdout = os.Stdout
	cmdIndex.Stderr = os.Stderr
	if err := cmdIndex.Run(); err != nil {
		fmt.Fprintf(os.Stderr, "cie index failed: %v\n", err)
		os.Exit(1)
	}

	// Файл для проверки: добавим и потом ищем по имени функции
	smokeFile := filepath.Join(repoRoot, "pkg", "ingestion", "smoke_test_helper.go")
	smokeContent := `// Code generated by mcp_smoke_test. DO NOT EDIT.
package ingestion

// SmokeTestHelperFunc существует только для смоук-теста MCP (поиск после реиндекса).
func SmokeTestHelperFunc() {}
`

	fmt.Println("=== 3. Создаём файл для проверки:", smokeFile)
	if err := os.WriteFile(smokeFile, []byte(smokeContent), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "write smoke file: %v\n", err)
		os.Exit(1)
	}
	defer os.Remove(smokeFile)

	fmt.Println("=== 4. Запуск cie --mcp и обмен JSON-RPC")
	cmd := exec.Command(cieBin, "--mcp")
	cmd.Dir = repoRoot
	cmd.Stderr = os.Stderr
	stdin, _ := cmd.StdinPipe()
	stdout, _ := cmd.StdoutPipe()
	if err := cmd.Start(); err != nil {
		fmt.Fprintf(os.Stderr, "start MCP: %v\n", err)
		os.Exit(1)
	}
	defer func() {
		stdin.Close()
		_ = cmd.Process.Kill()
		_ = cmd.Wait()
	}()

	scanner := bufio.NewScanner(stdout)
	scanner.Buffer(nil, 1024*1024)

	writer := bufio.NewWriter(stdin)
	send := func(method string, id int, params interface{}) {
		req := map[string]interface{}{"jsonrpc": "2.0", "id": id, "method": method}
		if params != nil {
			req["params"] = params
		}
		b, _ := json.Marshal(req)
		writer.Write(b)
		writer.WriteByte('\n')
		writer.Flush()
	}
	recv := func() string {
		if !scanner.Scan() {
			return ""
		}
		return strings.TrimSpace(scanner.Text())
	}

	// initialize
	send("initialize", 1, map[string]interface{}{"protocolVersion": "2024-11-05", "capabilities": map[string]interface{}{}})
	r1 := recv()
	if r1 == "" {
		fmt.Fprintf(os.Stderr, "no response to initialize\n")
		os.Exit(1)
	}
	fmt.Println("initialize OK")

	// notifications/initialized
	send("notifications/initialized", 0, map[string]interface{}{})
	// ответа нет

	// tools/call cie_index_status
	send("tools/call", 2, map[string]interface{}{
		"name":      "cie_index_status",
		"arguments": map[string]interface{}{},
	})
	r2 := recv()
	if r2 == "" {
		fmt.Fprintf(os.Stderr, "no response to cie_index_status\n")
		os.Exit(1)
	}
	fmt.Println("cie_index_status OK (first)")

	// tools/call cie_grep — ищем что-то существующее
	send("tools/call", 3, map[string]interface{}{
		"name":      "cie_grep",
		"arguments": map[string]interface{}{"text": "BuildIngestionConfig"},
	})
	r3 := recv()
	if r3 == "" {
		fmt.Fprintf(os.Stderr, "no response to cie_grep\n")
		os.Exit(1)
	}
	if !strings.Contains(r3, "BuildIngestionConfig") && !strings.Contains(r3, "content") {
		fmt.Fprintf(os.Stderr, "cie_grep unexpected: %s\n", r3[:min(200, len(r3))])
	}
	fmt.Println("cie_grep BuildIngestionConfig OK")

	// До реиндекса нового файла не должно быть в индексе
	send("tools/call", 4, map[string]interface{}{
		"name":      "cie_find_function",
		"arguments": map[string]interface{}{"name": "SmokeTestHelperFunc"},
	})
	r4 := recv()
	if r4 == "" {
		fmt.Fprintf(os.Stderr, "no response to cie_find_function (before reindex)\n")
		os.Exit(1)
	}
	// Ожидаем пустой результат или "no results" до реиндекса
	fmt.Println("cie_find_function SmokeTestHelperFunc (before reindex):", containsNoResults(r4))

	// Запуск реиндекса
	send("tools/call", 5, map[string]interface{}{
		"name":      "cie_reindex",
		"arguments": map[string]interface{}{"force_full": false},
	})
	r5 := recv()
	if r5 == "" {
		fmt.Fprintf(os.Stderr, "no response to cie_reindex\n")
		os.Exit(1)
	}
	if strings.Contains(r5, "in_progress") {
		fmt.Println("cie_reindex: already in progress, waiting...")
	}
	fmt.Println("cie_reindex OK")

	// Ждём завершения реиндекса (опрос статуса)
	for i := 0; i < 30; i++ {
		time.Sleep(1 * time.Second)
		send("tools/call", 10+i, map[string]interface{}{
			"name":      "cie_index_status",
			"arguments": map[string]interface{}{},
		})
		statusLine := recv()
		if statusLine == "" {
			continue
		}
		if strings.Contains(statusLine, "in_progress") {
			continue
		}
		if strings.Contains(statusLine, "Last run: completed") || i > 5 {
			break
		}
	}

	// После реиндекса ищем новый файл
	send("tools/call", 6, map[string]interface{}{
		"name":      "cie_find_function",
		"arguments": map[string]interface{}{"name": "SmokeTestHelperFunc"},
	})
	r6 := recv()
	if r6 == "" {
		fmt.Fprintf(os.Stderr, "no response to cie_find_function (after reindex)\n")
		os.Exit(1)
	}
	if strings.Contains(r6, "SmokeTestHelperFunc") && (strings.Contains(r6, "smoke_test_helper") || strings.Contains(r6, "content")) {
		fmt.Println("cie_find_function SmokeTestHelperFunc (after reindex): FOUND")
	} else {
		fmt.Printf("cie_find_function after reindex (maybe still indexing): %.200s...\n", r6)
	}

	fmt.Println("=== Smoke test done.")
}

func containsNoResults(s string) string {
	if strings.Contains(s, "No results") || strings.Contains(s, "0 result") {
		return "no results (expected before reindex)"
	}
	return "response received"
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
